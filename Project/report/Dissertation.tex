\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{graphicx}
\usepackage{biblatex}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{graphicx}
\usepackage{float}
\usepackage{scrextend}
\usepackage{hyperref}
\usepackage{caption}
\usepackage{subcaption}
 \usepackage{booktabs}
\usepackage[table,xcdraw]{xcolor}

\usepackage{amsthm}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]


\newcommand{\Enc}{\texttt{Enc}}
\newcommand{\Dec}{\texttt{Dec}}
\newcommand{\Gen}{\texttt{Gen}}

\newcommand{\M}{\mathcal{M}}
\newcommand{\C}{\mathcal{C}}
\newcommand{\K}{\mathcal{K}}
\newcommand{\A}{\mathcal{A}}

\newcommand{\Prob}{\mathbb{P}}

\newcommand{\Int}{\mathbb{Z}}

\newcommand{\Expr}[2]{\texttt{Expr}^{\texttt{#1}}_{#2}}

\addtokomafont{labelinglabel}{\sffamily}

\usepackage[a4paper, total={6in, 8in}]{geometry}

\addbibresource{dissertation.bib}

\title{CS4796: Joint Senior Honours Project}
\author{\{gf38\} @ st-andrews.ac.uk}

\makeatletter
\def\BState{\State\hskip-\ALG@thistlm}
\makeatother

\begin{document}

\begin{titlepage}
    \begin{center}
        \vspace*{1cm}
        
        \textbf{Fully homomorphic encryption}
        
        \vspace{0.5cm}
        
        CS4796: Joint Senior Honours Project \\
                
        
        \vspace{1cm}
        
        \textbf{Gergely Flamich}

        \vspace{0.5cm}
        Supervisors:\\
        Dr Sophie Huczynska, Prof Steve Linton
        
        \vfill
        
        \includegraphics[width=0.5\textwidth]{img/uni_crest}
        
        \vspace{0.8cm}
        
        School of Computer Science\\
        University of St Andrews\\
        Scotland\\
        
    \end{center}
\end{titlepage}

\begin{abstract}
\end{abstract}
\paragraph{Declaration}
We declare that the material submitted for assessment is my own work except where credit is explicitly given to others by citation or acknowledgement. This work was performed during the current academic year except where otherwise stated. The main text of this project report is NN,NNN* words long, including project specification and plan. In submitting this project report to the University of St Andrews, I give permission for it to be made available for use in accordance with the regulations of the University Library. I also give permission for the report to be made available on the Web, for this work to be used in research within the University of St Andrews, and for any software to be released on an open source basis. I retain the copyright in this work, and ownership of any resulting intellectual property.

\newpage

\tableofcontents

\newpage


\section{Introduction}
\section{Preliminaries}
\section{A Very Brief History of Ciphers}
\paragraph{}
The history of ciphers goes back at least 2000 years. We will now examine the
cipher now named after Julius Ceasar, who used the following method to obfuscate
his correspondance for his adversaries:
\paragraph{Ceasar Cipher}: Take the message (written using symbols from the
Latin alphabet) that we wish to obfuscate. Replace each symbol with the one that
comes 3 places after it in the alphabet. For letters at the end where we could
not shift, we ``wrap around'' to the beginning of the alphabet and carry on
counting from there. For example
\[
  \textit{Alea iacta est} \quad\to\quad \textit{Dohd mdfzd hxz}.
\]
To decrypt a message, we simply shift backwards by 3 positions, e.g.
\[
  \textit{Zhqm, zmgm, zmgm} \quad\to\quad \textit{Veni, vidi, vici}.
\]
\paragraph{}
We can further generalise this concept to arrive at the definiton of
\textit{shift ciphers}, where instead of the fixing the shift to 3, we pick a
key $k \in \mathbb{N}$, and we then shift $k$ places forward (and backwards).
With shift ciphers in mind, we now formally defined some key concepts that will
be used throughout this work.
\begin{definition}{Cipher:}
  Let $\M, \K_\Enc, \K_\Dec$ be finite sets of symbols. We will refer to $\M$
  as the \textbf{message space}.
  A cipher $C$ over $\M$, $\K_\Enc$ and $\K_\Dec$ is a tuple $(\Gen, \Enc, \Dec)$, where
  \begin{itemize}
  \item $\Gen$ is the \textbf{key generation algorithm}, which outputs a key
    $(k_\Enc, k_\Dec) \in (\K_\Enc^* \times \K_\Dec^*)$, chosen according to some
    distribution. We refer to the set $\K\subseteq \K_\Enc^* \times \K_\Dec^*$ of all possible outputs of $\Gen$ as the
    \textbf{key space} of $C$. If for all outputs we have $k_\Enc = k_\Dec$, then we call $C$
    a \textbf{symmetric cipher} and instead of the tuple we just write $k$.
    Otherwise we call $C$ an \textbf{asymmetric cipher}.
  \item $\Enc: \K_\Enc^*\times\M\to \M$ is the \textbf{encryption algorithm}, which takes
    a encryption key $k$ and a message $m$ and outputs its encoding $c$. We will often
    refer to the message as the \textbf{plaintext} and to the encrypted message
    as \textbf{ciphertext}.
  \item $\Dec: \K_\Dec^*\times\M \to \M$ is the \textbf{decryption algorithm}, which
    takes some decryption key $k$ and some ciphertext $c$ and outputs its
    correspnding plaintext $m$. 
  \end{itemize}
  Finally, we require the correctness of $C$, concretely
  \[
    \forall m \in \M, \forall (k, k') \in \K. \quad \Dec(k', \Enc(k, m)) = m,
  \]
  i.e. that the cipher does not change its contents.
\end{definition}

\paragraph{Equivalences of alphabets}
Consider any alphabet $\M = \{m_1, \hdots m_n\}$. It will be 
often convenient to consider the encoding of such an alphabet as something that
may be studied and manipulated more easily. Formally, by an encoding we mean a
bijection $f$ between our alphabet and some other set, where calculating values
of $f$ and $f^{-1}$ can both be done in polynomial time. Such an encoding may
be using ASCII for characters of the English alphabet or associating some
symbols with the elements of GF($p^n$). If there is such a bijection between
two alphabets, since one can be efficiently transformed into the other, we will
consider them equivalent.

\paragraph{Example}
Let us now revisit shift ciphers. In this case, for a set of $n$ symbols, it
will be easier to consider the encoding as elements of the additive group
$\Int_n$. First, it is easy to see that we are dealing with a
symmetric cipher, and since a shift by $k$ and any $k + xn, x \in \mathbb{N}$ is
going to be the same, $\K = \Int_n$. Then,
\begin{itemize}
\item $\Gen$: $\Gen$ is uniformly picking an element from $\Int_n$.
\item $\Enc$: We note that if we relabel our symbols to their
  indices (i.e. $m_i \to i$), then we can express our encryption function as
  \[
    \Enc(k, i) = i + k \mod n.
  \]
\item $\Dec$: Similarly, performing the above relabeling, we get
  \[
    \Dec(k, i) = i - k \mod n.
  \]
\end{itemize}
Now, checking the correctness of $C_{shift}$: Let $k, m \in \Int_n$
\[
  \Dec(k, \Enc(k, m)) = m + k \mod n - k \mod n = m + k - k \mod n = m \mod n = m.
\]
Since $k$ and $m$ were arbitrary, it holds $\forall m, k \in \Int_n$.
\paragraph{Kerckhoffs' principle}

\section{Perfect Security}
In order for us to be able to analyse our schemes, we must have two well defined
notions: what does it mean that a scheme is \textit{secure} and how \textit{powerful} is
the adversary who wishes to break our scheme.
\paragraph{The adversary} We will start from a rather
paranoid, but very useful perspective: we will assume that the adversary has
unbounded computational power. This means that we will have to fend off attacks
that may involve computing arbitrary \textit{decidable} functions, no matter how
long they take to calculate. Also, by Kerckhoff's principle we assume that the
adversary has perfect knowledge of both our encryption and decryption functions.
\paragraph{Security} We will also impose a very stringent constraint on what we
consider secure.
\begin{definition}{Perfect Security}
  \label{def:perfect_security}
We say that a scheme $\Pi$ is perfectly secure if
\[
  \forall m \in \M, c, c' \in \C.\quad \Prob(M=m \,|\, C=c) = \Prob(M=m \,|\, C=c').
\]
\end{definition}
\paragraph{Indistinguishability} We will require that given any ciphertext and a uniformly
random string from the cipher alphabet, the adversary cannot
\textit{distinguish} the two strings whatsoever. To formalise this, we will
first need to define a \textbf{security experiment}:
\paragraph{}
Let $\Pi = (\Gen, \Enc, \Dec)$ be a scheme, and $\A$ be any adversary.
Then, we will define $\texttt{Expr}^{\texttt{eav}}_{\Pi, \A}$ as
follows:
\begin{enumerate}
\item $\A$ generates two messages $m_0$ and $m_1$ from the message space $\M$.
\item A random bit $b$ is chosen from $\{0, 1\}$.
\item Put $k = \Gen()$ and $c = \Enc_k(m_b)$.
\item $\A$ is given $c$, and outputs $b'= \{0, 1\}$
\item The experiment outputs 1 if $b = b'$ and write $\Expr{eav}{\A, \Pi} = 1$,
  and 0 otherwise. If the output is 1, we say that $\A$ \textbf{succeeds}.
\end{enumerate}
Now, we are ready for our first definition of security:
\begin{definition}{Perfect Indistinguishability}
  \label{def:perfect_indistinguishability}
We say that a scheme $\Pi$ is perfectly indistinguishable iff for all adversaries $\A$
\[
  \Prob(\Expr{eav}{\A, \Pi} = 1) = \frac12.
\]
\end{definition}
\begin{theorem}
  \label{thm:perfect_equivalence}
A scheme $\Pi$ is perfectly secure if and only if it is perfectly indistinguishable.
\end{theorem}
\begin{proof}
  haha
\end{proof}
\begin{theorem}
A necessary condition for a scheme $\Pi = (\Gen, \Enc, \Dec)$ to be perfectly secure, is that $|\K|
\geq |\M|$.
\end{theorem}
\begin{proof}
  Assume $|\K| < |\M|$. We will show that this implies that perfect security is broken.\\
  The idea is to use the fact that if we are able to brute-force search through
  all the keys, we will learn some information about the keys and the messages.
  \paragraph{}
  For every $c \in \C$, let $\M_c = \{m \,|\, m = \Dec_k(c) k \in \K\}$.
  Note, that since $\Dec$ is a function, $|\M_c| \leq |K|$, as $\Dec$ may map two ciphertexts
  to the same plaintext for two different keys, but it can never map a
  ciphertext to two different plaintexts for the same key. Hence, $\M_c \subset
  \M$ and in particular $\M \setminus \M_c \neq \emptyset$.\\
  Now, fix $c \in \C$, and pick $m \in \M \setminus \M_c$. Since by definition
  $c$ cannot map to $m$, we have $\Prob(M=m | C = c) = 0$. But then
  \[
    \Prob(M=m) \neq 0 = \Prob(M=m | C=c)
  \]
  which violates perfect security, so our initial assumption must be false.
\end{proof}
\section{Computational Security}
\section{Public-Key Crypto Schemes}
\subsection{Euler's Theorem}
\subsection{An Example: RSA}
\section{Homomorphic Crypto Schemes}
\subsection{Definition}
\section{Paillier Encryption}
Paillier encryption is an additively homomorphic crypto scheme, that operates
over $\Int_{N^2}$ where $N = pq$ for some $p, q$ primes. In particular, it takes advantage of the fact that $\Int_{N^2}
\simeq \Int_{N} \times \Int_{N}^*$. 
\section{Fully Homomorphic Encryption}
\subsection{Lattices}
\subsection{GGH}
\subsection{Dr Craig Gentry's Scheme}

\printbibliography

\end{document}