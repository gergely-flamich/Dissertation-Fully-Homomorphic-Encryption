"""
The code below implements an improved version of
Craig Gentry's somewhat homomorphic cipher. It follows the 2010 paper

``Implementing Gentry's Fully-Homomorphic Encryption Scheme''

by Gentry and Halevi.
"""

def key_gen(N = 5, t = 32, num_retry = 10):
    """
    Key generation algorithm for Gentry's somewhat homomorphic cipher.

    @param N - the power of two used for the irreducible polynomial f(x) = x^n + 1
               where n = 2^N. Since we will be quotienting Z[x] by f, 2^N will also
               be the dimension of the lattice we are operating in.

    @param t - this parameter defines the magnitude of the coefficient of the
               polynomial that will generate us the principal ideal, that will
               correspond to our lattice. The magintude of t will directly
               influence the encryption and decryption radii.

    @param num_try - The number of times we attempt to find a polynomial p(x) where
                     its rotation basis' HNF is of the required shape.
                     By an observation of Nigel Smart, the probability that the
                     HNF is of the correct form has about probability a half, so
                     the default number of tries as 10 should be fine.
    """

    # Instantiate Z[x]
    Zx = PolynomialRing(ZZ, 'x')

    n = 2^N

    f = Zx(x^n + 1)

    # R = Z[x]/(x^n + 1)
    R = Zx.quotient(f)

    lower_bound = -2^(t-1)
    upper_bound = 2^(t-1)

    counter = 0

    for i in xrange(num_retry):

        counter = i + 1

        # Pick a random v(x) in R
        v = R.random_element(x=lower_bound, y=upper_bound)

        # Generate the rotation basis for v(x)
        V = v.matrix()

        # Calculate the "scaled" inverse w(x) of v(x) in R.
        # The reason why this is scaled is because the real inverse will
        # lie in the fractional ideal 1/(v(x)) and we can obtain it by dividing
        # w(x)'s coefficients by d.
        (d, w, _) = xgcd(v.lift(), f)

        w = R(w)

        # According to Gentry and Halevi, it is sufficient to check the
        # condition below to assure the HNF has the correct form
        Zd = Zmod(d)

        try:
            r = Zd(w[0]) * Zd(w[1]).inverse_of_unit()
        except ArithmeticError:
            continue

        if r^n == -1:
            break

    print("HNF in correct form after {} tries.".format(counter))

    # It is enough to store the first odd coefficient of w(x) as the private key
    w_i = filter(lambda x: x % 2 == 1, w)

    d = ZZ(d)
    r = ZZ(r)

    return (N, centered_mod(r, d), d), (d, w_i[0])

def hadamard_ratio(basis):
    """
    The Hadamard ratio of a full rank lattice basis.

    Given any N-dimensional parallelepiped, the one that maximises the volume
    is the N-orthope (N-dimensional rectangle). The Hadamard ratio measures how
    orthogonal the vectors of a lattice basis are with respect to each other.
    The way it does this by comparing the volume of the lattice basis' fundamental
    domain against the N-orthope with the same sidelengths.
    """

    if basis is None:
        return 0

    vol = abs(det(basis))
    block = product(map(norm, basis))

    return n((vol/block)^(1/basis.rank()))


def encrypt(pk, plaintext, u=None):
    """
    Encryption function of Gentry's somewhat homomorphic scheme.

    @param pk - the public key generated by key_gen
    @param plaintext - the message we wish to encode. Due to the ideal (2) we will
                       be working with, we only allow the two bits 0 and 1 as
                       messages
    @param u - We can use a previously generated perturbation vector, only for
               testing
    """

    if plaintext != 0 and plaintext != 1:
        raise ArithmeticError("Plaintext must be a bit!")

    N, r, d = pk

    # Instantiate the ring
    Zx = PolynomialRing(ZZ, 'x')

    n = 2^N

    f = Zx(x^n + 1)

    R = Zx.quotient(f)

    # Generate a perturbation vector with small Euclidean norm
    p = 10/n

    p = 0.5 if p > 0.5 else p

    if u is None:
        u_coeff_vec = [0 if abs(candidate) > p else sgn(candidate) for candidate in random_vector(RR, n)]
        u = R(u_coeff_vec)

    print("Perturbation is {} dimensional and has {} non-zero entries.".format(n, sum(map(abs, u))))
    print("Namely, u(x) = {}".format(u))

    a = 2 * u

    # To encode the message, we use the trick described in Gentry and Halevi's paper.
    return (a.lift()(r) + plaintext).mod(d)


def decrypt(sk, ciphertext):
    """
    Decryption function.

    @sk - Secret key, as output by key_gen, see above.
    @ciphertext - representation of the n-dimensional lattice vector
                  we wish to decrypt. According to Gentry and Halevi's
                  trick, it will only be the first entry of the lattice vector.
    """

    d, w_i = sk

    e = (ciphertext * w_i).mod(d)

    b = e.mod(2)

    if d % 2 == 1 and 2*e >= d:
        b = 1 - b

    return b


def centered_mod(x, modulus):
    """
    Centered modulo, in the following sense:

    d mod n  is in  [0, n)

    whereas

    d cmod n  is in  [-n/2, n/2)
    """

    x = ZZ(x)
    res = x.mod(modulus)
    half_mod = (modulus + 1)//2

    return  res if res < half_mod else res - modulus
